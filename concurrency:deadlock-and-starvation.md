# 并发：死锁和饥饿

> 继续讨论并发问题，并着重讲述在并发处理中通常要解决的两个问题：死锁和饥饿。从死锁的基本原理和饥饿的相关问题开始讨论，接着分析死锁的三种常用方法：预防、检测和避免，然后考虑用于说明同步和死锁的一个经典问题：哲学家就餐问题。

**死锁的原理** ：可以把死锁定义为一组相互竞争资源或者进行通信的进程的"永久"阻塞。当一组进程中的每个进程都在等待某个事件（典型的情况是等待所请求资源的释放），而只有在这组进程中的其它被阻塞的进程才可以触发该事件，这时就称这组进程发生死锁。因为没有事件能够被触发，故死锁是永久性的。

资源通常分为两类：可重用的和可消耗的。可重用资源是指一次只能供一个进程安全地使用，并且不会由于使用而耗尽的资源。进程得到资源单元，后来又释放这些单元，供其它进程再次使用。可重用资源的例子包括处理器、`I/O`通道、内存和外存、设备以及诸如文件等；可消耗资源是指可以被创建和销毁的资源。可消耗资源的例子有中断、信号、消息和`I/O`缓冲区的信息。

产生死锁的三个必要条件：

1）互斥，一次只有一个进程可以使用一个资源。其它进程不能访问已分配给其它进程的资源；

2）占有且等待，当一个进程等待其它进程时，继续占有已经分配的资源；

3）不可抢占，不能强行抢占进程已占有的资源；

4）循环等待，存在一个封闭的进程链，使得每个进程至少占有此链所需要的一个资源；

资源分配拒绝又称为银行家算法，最初是在[`DIJK65`]中提出的，首先需要定义状态和安全状态的概念。考虑一个系统，它有固定数目的进程和固定数目的资源，任何时候一个进程可能分配到零个或多个资源。系统的状态是当前给进程分配的资源情况，因此，状态包含前面定义的两个向量`Resource`和`Available`以及两个矩阵`Claim`和`Allocation`。**安全状态**是指至少有一个资源分配序列不会导致死锁（即所有进程都能运行直到结束），**不安全状态**当然就是指一个不安全的状态。

## 哲学家就餐问题 

现在来考虑`Dijkstra[DIJK71]`引入的哲学家就餐问题。有`5`位哲学家住在一座房子里，在他们的面前有一张餐桌。每位哲学家的生活就是思考和吃饭。经过多年的思考，所有的哲学家一致同意最有助于他们思考的食物是意大利面条。由于缺乏手工技能，每位哲学家需要两把叉子来吃意大利面条。

问题：一个圆桌上有一大碗面，`5`个盘子，每位哲学家一个，还有`5`把叉子。每个想吃饭的哲学家将坐到桌子旁分配给他的位置，使用盘子两侧的叉子取面和吃面。请设计一个礼仪（算法）以允许哲学家吃饭。算法必须保证互斥（没有两位哲学家同时使用同一把叉子），同时还要避免死锁和饥饿。

```c
monitor dining_controller;
cond ForkReady[5];  /* condition variable for synchronization */
boolean fork[5] = {true}; /* availability status of each fork */
/* pid is the philospher id number */
void get_forks(int pid) {
  int left = pid;
  int right [++pid] % 5;
  /* grant the left fork */
  if (!fork(left))
    cwait(ForkReady(left));		/* queue on condition variable */
  /* grant the right fork */
  if (fork(right)) 
    cwait(ForkReady(right))  /* queue on condition variable */
  fork(right) = flase;
}
void release_forks(int pids) {
  int left = pid;
  int right (++pid) % 5;
  /* release the left fork */
  if (empty(ForkReady[left]))	 /* no one is waiting for this fork */
    fork(left) = true;
  else	/* awaken a process waiting on this fork */
    csignal(ForkReady[left])
  /* release the right fork */
  if (empty(ForkReady[right]))   /* no one is waiting for this fork */
    fork(right) = true;
  else	/* awaken a process waiting on this fork */
    csignal(ForkReady[right])
}

/* the five philospher clients */
void philosopher[k=0 to 4]
{
  while(true) {
    <think>;
    get_forks(k);    /* client requests two forks via monitor */
  	<eat spaghetti>;
    release_forks(k);  /* client releases forks via the monitor */
  }
}
```

在`linux`中保护临界区最常见的技术是自旋锁（`spinlock`）。在同一时刻，只有一个线程能获得自旋锁。其他企图获得自旋锁的任何线程将一直进行尝试（即自旋），直到获得了该锁。本质上，自旋锁建立在内存区中的一个整数上，任何线程进入临界区之前都必须检查该整数。



## Q&A 复习题

1. 给出可重用资源和可消耗资源的例子。

   答：可重用资源的示例是处理器、`I/O`通道、主存储器和辅助存储器，设备以及诸如文件，数据库和信号量之类的数据结构。消耗性资源示例包括`I/O`缓存区的中断、信号、消息和信息。

2. 产生死锁的三个必要条件是什么？

   答：互斥，一次只能有一个进程使用资源；保持并等待，一个进程可以等待其它进程分配的同时保留分配的资源；没有抢占，不能从拥有它的进程中强行删除任何资源。

3. 产生死锁的`4`个条件是什么？

   答：以上的三个必要条件，加上循环等待。存在一个封闭的流程链，这样每个流程都拥有链中下一流程所需的最少一个资源。

4. 如何防止占有且等待条件？

   答：可以通过要求一个进程一次性请求所有其所需资源，并阻塞该进程直到可以同时授予所有请求，来防止保持等待状态。

5. 给出防止不可抢占条件的两种方法。

   答：首先，如果一个拥有某些资源的进程被拒绝进一步的请求，则该进程必须释放其原有资源，并在必要时再次与附加资源一起请求它们。可选地，如果一个进程请求当前另一个进程持有的资源，则操作系统可以抢占第二进程并要求其释放其资源。

6. 如何防止循环等待条件？

   答：通过定义资源类型的线性顺序可以避免循环等待条件。如果已为进程分配了`R`的资源，则它随后可以仅在排序中请求`R`之后的那些资源类型。

7. 思索避免、检测和预防之间的区别是什么？

   答：死锁预防限制了资源请求，以防止死锁的四种情况中的至少一种，这可以通过防止三个必要的政策条件（互斥、保留和等待，无抢占）之一间接完成，或者可防止循环等待来直接完成；死锁避免可以满足三个必要条件，但是要做出明智的选择以确保永远不会达到死锁点。通过死锁检测，尽可能将请求的资源授予进程。操作系统定期执行一种算法，使其能够检测循环等待条件。